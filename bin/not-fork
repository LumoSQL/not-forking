#!/usr/bin/perl -w

# Copyright 2020 The LumoSQL Authors, see LICENSES/MIT
#
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2020 The LumoSQL Authors
# SPDX-ArtifactOfProjectName: not-forking
# SPDX-FileType: Code
# SPDX-FileComment: Original by Claudio Calvelli, 2020

# LumoSQL "not-fork" tool: track upstream changes to other packages
# with consistent local modifications (没叉 or 不叉)

# Requires integration between version control systems used and perl,
# for example to use git it needs to be built with perl support, which
# is the default; other VCSs may need to install perl modules.

# See the /doc directory for more information about this tool

use strict;
use FindBin qw($Script);
use Getopt::Long qw(GetOptions GetOptionsFromArray);

# modules may be inside the working copy rather than installed
#use FindBin;
#use lib "$FindBin::Bin/../lib";

use NotFork::Get qw(
    set_input
    set_cache
    set_output
    get_output
    all_names
    version_atleast
    recommend
);

our $VERSION = '0.4';

Getopt::Long::Configure("bundling");

my ($version, $commit, $query, $help, $noupdate, $check_version, $list_versions);
my ($offline, $my_version, $check_prereq, $check_recommend, $find_version, @names);
my $verbose = 1;
my @options = (
    'c|commit=s'       => \$commit,
    'h|?|help'         => \$help,
    'i|input=s'        => sub { set_input($_[1]) },
    'k|cache=s'        => sub { set_cache($_[1]) },
    'n|no-update'      => \$noupdate,
    'update'           => sub { $noupdate = 0 },
    'o|output=s'       => sub { set_output($_[1]) },
    'q|query'          => \$query,
    'verbose=i'        => \$verbose,
    'quiet'            => sub { $verbose = 0 },
    'online'           => sub { $offline = 0 },
    'offline'          => \$offline,
    'v|version=s'      => \$version,
    'list-versions'    => \$list_versions,
    'check-version=s'  => \$check_version,
    'check-prereq'     => \$check_prereq,
    'check-recommend'  => \$check_recommend,
    'V|my-version'     => \$my_version,
    'find-version=s'   => \$find_version,
    '<>'               => \&add_name,
);

if (defined (my $home = $ENV{HOME})) {
    # read the first configuration file we find
    my $cfile = "$home/.config/LumoSQL/not-fork.conf";
    if (open (my $cfh, "<", $cfile)) {
	my @config = ();
	while (defined (my $line = <$cfh>)) {
	    $line =~ /^\s*$/ and next;
	    $line =~ /^\s*#/ and next;
	    chomp $line;
	    $line =~ s/\s*=\s*/=/;
	    push @config, '--' . $line;
	}
	close $cfh;
	GetOptionsFromArray(\@config, @options) or usage(1);
    }
}
GetOptions(@options) or usage(1);

$help and usage(0);

if (defined $my_version) {
    print "$VERSION\n";
    exit 0;
}

if (defined $check_version) {
    version_atleast($VERSION, $check_version) and exit 0;
    print "$VERSION\n";
    exit 1;
}

my ($min_version, $max_version);
if (defined $find_version) {
    $min_version = $find_version;
    my $ok = 1;
    if ($min_version =~ s/:(.*)$//) {
	$max_version = $1;
	$ok = version_atleast($max_version, $VERSION);
    }
    $ok &&= version_atleast($VERSION, $min_version);
    if ($ok) {
	# OK, the running version is OK, how do we call it?
	(my $lib = $FindBin::Bin) =~ s|/[^/]+$|/lib|;
	if (-d "$lib/NotFork") {
	    # program is running from source dir
	    print "$^X\n";
	    print "-I$lib\n";
	    print "$0\n";
	} else {
	    # program is installed
	    print "$0\n";
	}
	exit 0;
    }
    # we are not in the required range, but we can not-fork ourselves
    # to find it; we rewrite the command-line options to find our own
    # configuration and then continue as normal
    undef $commit;
    undef $version; # we'll check later
    for my $inc (@INC, undef) {
	defined $inc or die "Cannot find not-forking configuration\n";
	-f "$inc/NotFork/not-fork.d/not-fork/upstream.conf" or next;
	set_input("$inc/NotFork/not-fork.d");
	last;
    }
    @names = ();
    add_name('not-fork');
    # now continue as normal for a bit
}

my %prereq;
if (defined $check_recommend) {
    %prereq = recommend();
    my $found_all = list_prereq();
    exit $found_all ? 0 : 1
}

if (! @names) {
    for my $name (all_names()) {
	push @names, [$name, $version, $commit];
    }
}

%prereq = ();
for my $np (@names) {
    my ($name, $version, $commit) = @$np;
    my $nfobj = new NotFork::Get($name, $version, $commit);
    defined $verbose and $nfobj->verbose($verbose);
    defined $offline and $nfobj->offline($offline);
    if ($check_prereq) {
	$nfobj->check_prereq(\%prereq);
    } else {
	$nfobj->get($noupdate);
	if (defined $find_version) {
	    my @v = grep { version_atleast($_, $min_version) } $nfobj->all_versions;
	    defined $max_version and @v = grep { version_atleast($max_version, $_) } @v;
	    @v or die "No suitable versions found\n";
	    # great, just get the latest in range and we're done
	    my $v = pop @v;
	    $nfobj = new NotFork::Get($name, $v, undef);
	    defined $verbose and $nfobj->verbose($verbose);
	    defined $offline and $nfobj->offline($offline);
	    $nfobj->get(1);
	}
	if ($list_versions || $query) {
	    $query and $nfobj->info(\*STDOUT);
	    $list_versions and print map { "$_\n" } $nfobj->all_versions;
	} else {
	    $nfobj->install();
	    if (defined $find_version) {
		my $dir = get_output() . "/$nfobj->{name}";
		-f "$dir/bin/not-fork" or die "Internal error, sources not in $dir\n";
		print "$^X\n";
		print "-I$dir/lib\n";
		print "$dir/bin/not-fork\n";
		exit 0;
	    }
	}
    }
}

if ($check_prereq) {
    my $found_all = list_prereq();
    exit $found_all ? 0 : 1;
}

sub add_name {
    my ($name) = @_;
    defined $version && defined $commit and usage();
    push @names, [$name, $version, $commit];
    undef $version;
    undef $commit;
}

sub usage {
    my ($code) = @_;
    my $fh = $code ? \*STDERR : \*STDOUT;
    print $fh "This is $Script version $VERSION\n\n";
    print $fh "Usage: $Script [options] [NAME]...\n";
    print $fh "\n";
    print $fh "-iDIR --input=DIR\n";
    print $fh "    Specify configuration directory, default: ./not-fork.d\n";
    print $fh "-oDIR --output=DIR\n";
    print $fh "    Specify output directory, default: ./sources\n";
    print $fh "-vVERSION --version=VERSION | -cID --commit=ID\n";
    print $fh "    Specify what version or commit ID (if supported) to obtain,\n";
    print $fh "    the two are mutually exclusive, default: latest available\n";
    print $fh "--list-versions\n";
    print $fh "    List all known versions of the NAMEs specified\n";
    print $fh "-kDIR --cache=DIR\n";
    print $fh "    Specify download cache directory, default: \$HOME/.cache/LumoSQL/not-fork\n";
    print $fh "-q --query\n";
    print $fh "    Obtain upstream sources but do not extract them and instead\n";
    print $fh "    show information about them and which version would be selected\n";
    print $fh "--verbose=LEVEL | --quiet\n";
    print $fh "    Ask to show more information about the processing; default is 1\n";
    print $fh "    which just summarises what's going on; 0 disables all output except\n";
    print $fh "    error messages; higher number are only useful for debugging or to\n";
    print $fh "    know exactly what the program does; --quiet is the same as\n";
    print $fh "    --verbose=0\n";
    print $fh "--update | --no-update\n";
    print $fh "    --no-update skips updates from upstream if there is already a cached\n";
    print $fh "    version; --update is the default action of checking for upstream\n";
    print $fh "    updates before extracting the sources\n";
    print $fh "--online | --offline\n";
    print $fh "    --offline skips any operation which needs to access the network;\n";
    print $fh "    this may result in the program stopping with an error if the data\n";
    print $fh "    is not available on a local cache; --online is the default where the\n";
    print $fh "    network can be accessed if required\n";
    print $fh "-V --my-version\n";
    print $fh "    Print version number of not-fork\n";
    print $fh "--check_version=NUMBER\n";
    print $fh "    If the version of not-fork is NUMBER or later, exit with a success\n";
    print $fh "    code; if it's older, print the current version and exit with failure\n";
    print $fh "--check-prereq\n";
    print $fh "    check that all dependencies are installed; if so, exit with a\n";
    print $fh "    success code; otherwise print what's missing and fail\n";
    print $fh "--check-recommend\n";
    print $fh "    like --check-prereq however it lists all possible dependencies\n";
    print $fh "    whether they are used for this particular project or not\n";
    print $fh "\n";
    print $fh "-c/-v needs to be specified before each NAME, after a NAME has\n";
    print $fh "been processed, these options revert to the default\n";
    exit $code;
}

sub list_prereq {
    my $title = 1;
    my $found_all = 1;
    my @prereq = sort { lc($a) cmp lc($b) || $a cmp $b } keys %prereq;
    my $maxv = 0;
    for my $name (@prereq) {
	my ($ok, $version) = @{$prereq{$name}};
	$ok && $verbose < 1 and next;
	defined $version && $maxv < length($version) and $maxv = length($version);
    }
    for my $name (@prereq) {
	my ($ok, $version) = @{$prereq{$name}};
	$ok && $verbose < 1 and next;
	$ok or $found_all = 0;
	if ($verbose < 1) {
	    if ($title) {
		$title = 0;
		print "\nWARNING - recommended program and/or perl modules not found\n";
	    }
	    if (defined $version && $version ne '') {
		print "$name >= $version\n";
	    } else {
		print "$name\n";
	    }
	} else {
	    if ($title) {
		$title = 0;
		print "Recommended programs and perl modules\n";
	    }
	    defined $version or $version = '';
	    printf "%-9s %-${maxv}s %s\n", $ok ? 'OK' : 'NOT FOUND', $version, $name;
	}
    }
}

