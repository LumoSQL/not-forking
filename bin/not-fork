#!/usr/bin/perl -w

# Copyright 2020 The LumoSQL Authors, see LICENSES/MIT
#
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: 2020 The LumoSQL Authors
# SPDX-ArtifactOfProjectName: not-forking
# SPDX-FileType: Code
# SPDX-FileComment: Original by Claudio Calvelli, 2020

# LumoSQL "not-fork" tool: track upstream changes to other packages
# with consistent local modifications (没叉 or 不叉)

# Requires integration between version control systems used and perl,
# for example to use git it needs to be built with perl support, which
# is the default; other VCSs may need to install perl modules.

# See the /doc directory for more information about this tool

use strict;
use FindBin qw($Script);
use Getopt::Long qw(GetOptions GetOptionsFromArray);

# modules may be inside the working copy rather than installed
#use FindBin;
#use lib "$FindBin::Bin/../lib";

use NotFork::Get qw(set_input set_cache set_output all_names version_atleast recommend);

our $VERSION = '0.3';

Getopt::Long::Configure("bundling");

my ($version, $commit, $query, $help, $noupdate, $check_version, $list_versions);
my ($my_version, $check_prereq, $check_recommend, @names);
my $verbose = 1;
my @options = (
    'c|commit=s'       => \$commit,
    'h|?|help'         => \$help,
    'i|input=s'        => sub { set_input($_[1]) },
    'k|cache=s'        => sub { set_cache($_[1]) },
    'n|no-update'      => \$noupdate,
    'update'           => sub { $noupdate = 0 },
    'o|output=s'       => sub { set_output($_[1]) },
    'q|query'          => \$query,
    'verbose=i'        => \$verbose,
    'quiet'            => sub { $verbose = 0 },
    'v|version=s'      => \$version,
    'list-versions'    => \$list_versions,
    'check-version=s'  => \$check_version,
    'check-prereq'     => \$check_prereq,
    'check-recommend'  => \$check_recommend,
    'V|my-version'     => \$my_version,
    '<>'               => \&add_name,
);

if (defined (my $home = $ENV{HOME})) {
    # read the first configuration file we find
    my $cfile = "$home/.config/LumoSQL/not-fork.conf";
    if (open (my $cfh, "<", $cfile)) {
	my @config = ();
	while (defined (my $line = <$cfh>)) {
	    $line =~ /^\s*$/ and next;
	    $line =~ /^\s*#/ and next;
	    chomp $line;
	    $line =~ s/\s*=\s*/=/;
	    push @config, '--' . $line;
	}
	close $cfh;
	GetOptionsFromArray(\@config, @options) or usage(1);
    }
}
GetOptions(@options) or usage(1);

$help and usage(0);

if (defined $my_version) {
    print "$VERSION\n";
    exit 0;
}

if (defined $check_version) {
    version_atleast($VERSION, $check_version) and exit 0;
    print "$VERSION\n";
    exit 1;
}

my %prereq;
if (defined $check_recommend) {
    %prereq = recommend();
    my $found_all = list_prereq();
    exit $found_all ? 0 : 1
}

if (! @names) {
    for my $name (all_names()) {
	push @names, [$name, $version, $commit];
    }
}

%prereq = ();
for my $np (@names) {
    my ($name, $version, $commit) = @$np;
    my $nfobj = new NotFork::Get($name, $version, $commit);
    $nfobj->verbose($verbose);
    if ($check_prereq) {
	$nfobj->check_prereq(\%prereq);
    } else {
	$nfobj->get($noupdate);
	if ($list_versions || $query) {
	    $query and $nfobj->info(\*STDOUT);
	    $list_versions and print map { "$_\n" } $nfobj->all_versions;
	} else {
	    $nfobj->install();
	}
    }
}

if ($check_prereq) {
    my $found_all = list_prereq();
    exit $found_all ? 0 : 1;
}

sub add_name {
    my ($name) = @_;
    defined $version && defined $commit and usage();
    push @names, [$name, $version, $commit];
    undef $version;
    undef $commit;
}

sub usage {
    my ($code) = @_;
    my $fh = $code ? \*STDERR : \*STDOUT;
    print $fh "This is $Script version $VERSION\n\n";
    print $fh "Usage: $Script [options] [NAME]...\n";
    print $fh "\n";
    print $fh "-iDIR --input=DIR\n";
    print $fh "    Specify configuration directory, default: ./not-fork.d\n";
    print $fh "-oDIR --output=DIR\n";
    print $fh "    Specify output directory, default: ./sources\n";
    print $fh "-vVERSION --version=VERSION | -cID --commit=ID\n";
    print $fh "    Specify what version or commit ID (if supported) to obtain,\n";
    print $fh "    the two are mutually exclusive, default: latest available\n";
    print $fh "--list-versions\n";
    print $fh "    List all known versions of the NAMEs specified\n";
    print $fh "-kDIR --cache=DIR\n";
    print $fh "    Specify download cache directory, default: \$HOME/.cache/LumoSQL/not-fork\n";
    print $fh "-q --query\n";
    print $fh "    Obtain upstream sources but do not extract them and instead\n";
    print $fh "    show information about them and which version would be selected\n";
    print $fh "--verbose=LEVEL | --quiet\n";
    print $fh "    Ask to show more information about the processing; default is 1\n";
    print $fh "    which just summarises what's going on; 0 disables all output except\n";
    print $fh "    error messages; higher number are only useful for debugging or to\n";
    print $fh "    know exactly what the program does; --quiet is the same as\n";
    print $fh "    --verbose=0\n";
    print $fh "--update | --no-update\n";
    print $fh "    --no-update skips updates from upstream if there is already a cached\n";
    print $fh "    version; --update is the default action of checking for upstream\n";
    print $fh "    updates before extracting the sources\n";
    print $fh "-V --my-version\n";
    print $fh "    Print version number of not-fork\n";
    print $fh "--check_version=NUMBER\n";
    print $fh "    If the version of not-fork is NUMBER or later, exit with a success\n";
    print $fh "    code; if it's older, print the current version and exit with failure\n";
    print $fh "--check-prereq\n";
    print $fh "    check that all dependencies are installed; if so, exit with a\n";
    print $fh "    success code; otherwise print what's missing and fail\n";
    print $fh "--check-recommend\n";
    print $fh "    like --check-prereq however it lists all possible dependencies\n";
    print $fh "    whether they are used for this particular project or not\n";
    print $fh "\n";
    print $fh "-c/-v needs to be specified before each NAME, after a NAME has\n";
    print $fh "been processed, these options revert to the default\n";
    exit $code;
}

sub list_prereq {
    my $title = 1;
    my $found_all = 1;
    my @prereq = sort { lc($a) cmp lc($b) || $a cmp $b } keys %prereq;
    my $maxv = 0;
    for my $name (@prereq) {
	my ($ok, $version) = @{$prereq{$name}};
	$ok && $verbose < 1 and next;
	$maxv < length($version) and $maxv = length($version);
    }
    for my $name (@prereq) {
	my ($ok, $version) = @{$prereq{$name}};
	$ok && $verbose < 1 and next;
	$ok or $found_all = 0;
	if ($verbose < 1) {
	    if ($title) {
		$title = 0;
		print "\nWARNING - recommended program and/or perl modules not found\n";
	    }
	    if (defined $version && $version ne '') {
		print "$name >= $version\n";
	    } else {
		print "$name\n";
	    }
	} else {
	    if ($title) {
		$title = 0;
		print "Recommended programs and perl modules\n";
	    }
	    defined $version or $version = '';
	    printf "%-9s %-${maxv}s %s\n", $ok ? 'OK' : 'NOT FOUND', $version, $name;
	}
    }
}

